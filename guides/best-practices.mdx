---
title: 'Best Practices'
description: 'Guidelines for building secure, reliable, and cost-effective AI voice applications'
---

This guide covers essential best practices for building production-ready AI voice applications with TalkOS, including security, error handling, scaling, and cost optimization.

## API Key Security

<Warning>
Never expose your API keys in client-side code, public repositories, or logs. Compromised keys can result in unauthorized usage and charges.
</Warning>

### Environment Variables

Always store API keys in environment variables:

<CodeGroup>

```bash .env
# Never commit this file to version control
TALKOS_API_KEY=tk_live_xxxxxxxxxxxxxxxxxxxx
TALKOS_WEBHOOK_SECRET=whsec_xxxxxxxxxxxxx
```

```javascript config.js
// Load from environment
const config = {
  apiKey: process.env.TALKOS_API_KEY,
  webhookSecret: process.env.TALKOS_WEBHOOK_SECRET
};

// Validate at startup
if (!config.apiKey) {
  throw new Error('TALKOS_API_KEY environment variable is required');
}
```

```python config.py
import os

API_KEY = os.environ.get('TALKOS_API_KEY')
WEBHOOK_SECRET = os.environ.get('TALKOS_WEBHOOK_SECRET')

if not API_KEY:
    raise ValueError('TALKOS_API_KEY environment variable is required')
```

</CodeGroup>

### Key Rotation

Rotate API keys periodically and immediately if compromised:

<Steps>
  <Step title="Generate New Key">
    ```bash
    curl -X POST https://api.talkos.io/api/tenants/rotate-key \
      -H "x-api-key: YOUR_CURRENT_API_KEY"
    ```
  </Step>
  
  <Step title="Update Your Applications">
    Deploy the new key to all your applications before the old key expires.
  </Step>
  
  <Step title="Verify New Key Works">
    Test API calls with the new key before deactivating the old one.
  </Step>
  
  <Step title="Revoke Old Key">
    ```bash
    curl -X DELETE https://api.talkos.io/api/tenants/keys/OLD_KEY_ID \
      -H "x-api-key: YOUR_NEW_API_KEY"
    ```
  </Step>
</Steps>

### IP Allowlisting

Restrict API access to known IP addresses:

```bash
curl -X PUT https://api.talkos.io/api/config \
  -H "x-api-key: YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "security": {
      "allowedIPs": [
        "203.0.113.0/24",
        "198.51.100.42"
      ]
    }
  }'
```

## Error Handling

### Retry Logic with Exponential Backoff

Implement robust retry logic for transient failures:

```javascript api-client.js
class TalkOSClient {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.baseUrl = 'https://api.talkos.io';
    this.maxRetries = 3;
    this.baseDelay = 1000; // ms
  }

  async request(method, path, body = null, attempt = 1) {
    try {
      const response = await fetch(`${this.baseUrl}${path}`, {
        method,
        headers: {
          'x-api-key': this.apiKey,
          'Content-Type': 'application/json'
        },
        body: body ? JSON.stringify(body) : null
      });

      // Handle rate limiting
      if (response.status === 429) {
        const retryAfter = parseInt(response.headers.get('Retry-After') || '60');
        if (attempt <= this.maxRetries) {
          console.log(`Rate limited. Retrying in ${retryAfter}s...`);
          await this.sleep(retryAfter * 1000);
          return this.request(method, path, body, attempt + 1);
        }
        throw new Error('Rate limit exceeded after max retries');
      }

      // Handle server errors with retry
      if (response.status >= 500 && attempt <= this.maxRetries) {
        const delay = this.baseDelay * Math.pow(2, attempt - 1);
        console.log(`Server error. Retrying in ${delay}ms...`);
        await this.sleep(delay);
        return this.request(method, path, body, attempt + 1);
      }

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || `HTTP ${response.status}`);
      }

      return response.json();
    } catch (error) {
      if (error.name === 'TypeError' && attempt <= this.maxRetries) {
        // Network error - retry
        const delay = this.baseDelay * Math.pow(2, attempt - 1);
        console.log(`Network error. Retrying in ${delay}ms...`);
        await this.sleep(delay);
        return this.request(method, path, body, attempt + 1);
      }
      throw error;
    }
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async startCall(params) {
    return this.request('POST', '/api/calls/start', params);
  }
}
```

### Error Types and Handling

| Error Code | Meaning | Action |
|------------|---------|--------|
| 400 | Bad Request | Fix request parameters |
| 401 | Unauthorized | Check API key validity |
| 403 | Forbidden | Check permissions/IP allowlist |
| 404 | Not Found | Verify resource exists |
| 429 | Rate Limited | Implement backoff, reduce frequency |
| 500 | Server Error | Retry with exponential backoff |
| 503 | Service Unavailable | Retry after delay |

### Graceful Degradation

Handle failures without breaking user experience:

```javascript call-service.js
async function initiateCall(phoneNumber, options) {
  try {
    const result = await talkos.startCall({
      to: phoneNumber,
      ...options
    });
    return { success: true, callId: result.callUUID };
  } catch (error) {
    console.error('Call initiation failed:', error.message);
    
    // Log for monitoring
    await logError({
      type: 'call_initiation_failed',
      phone: phoneNumber,
      error: error.message,
      timestamp: new Date()
    });

    // Return graceful failure
    return {
      success: false,
      error: 'Unable to place call at this time',
      retryable: error.status >= 500 || error.status === 429
    };
  }
}
```

## Scaling

### Rate Limit Management

<CardGroup cols={2}>
  <Card title="Request Queuing" icon="layer-group">
    Queue requests to stay within rate limits
  </Card>
  <Card title="Concurrent Limits" icon="gauge">
    Respect concurrent call limits
  </Card>
  <Card title="Batch Efficiently" icon="boxes-stacked">
    Use batch API for bulk operations
  </Card>
  <Card title="Monitor Usage" icon="chart-line">
    Track API usage and limits
  </Card>
</CardGroup>

### Request Queue Implementation

```javascript request-queue.js
import Bottleneck from 'bottleneck';

// Create rate limiter matching your plan limits
const limiter = new Bottleneck({
  reservoir: 60,           // Initial requests available
  reservoirRefreshAmount: 60, // Requests to add each interval
  reservoirRefreshInterval: 60 * 1000, // Refresh every minute
  maxConcurrent: 10,       // Max concurrent requests
  minTime: 100             // Min time between requests (ms)
});

// Wrap API calls with limiter
const rateLimitedStartCall = limiter.wrap(async (params) => {
  return talkos.startCall(params);
});

// Use throughout your app
async function processCampaign(contacts) {
  const results = await Promise.all(
    contacts.map(contact =>
      rateLimitedStartCall({
        to: contact.phone,
        greeting: `Hi ${contact.name}!`,
        metadata: { contactId: contact.id }
      })
    )
  );
  return results;
}
```

### Connection Pooling

For high-volume applications, use connection pooling:

```javascript http-client.js
import { Agent } from 'https';

const agent = new Agent({
  keepAlive: true,
  maxSockets: 50,
  maxFreeSockets: 10,
  timeout: 30000
});

const fetchWithPool = (url, options) => {
  return fetch(url, { ...options, agent });
};
```

### Horizontal Scaling

<AccordionGroup>
  <Accordion title="Stateless Design">
    - Don't store session data in memory
    - Use Redis for shared state
    - Enable load balancing across instances
  </Accordion>
  
  <Accordion title="Webhook Processing">
    - Use a message queue (Redis, RabbitMQ) for webhooks
    - Process webhooks asynchronously
    - Scale webhook workers independently
  </Accordion>
  
  <Accordion title="Database Optimization">
    - Index frequently queried fields
    - Use connection pooling
    - Consider read replicas for analytics
  </Accordion>
</AccordionGroup>

## Cost Optimization

### Monitor Usage

Track your API usage to identify optimization opportunities:

```bash
curl -X GET https://api.talkos.io/api/analytics/usage \
  -H "x-api-key: YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "startDate": "2026-02-01",
    "endDate": "2026-02-18",
    "groupBy": "day"
  }'
```

### Call Duration Optimization

<Note>
You're billed per minute of call duration. Optimizing call efficiency directly impacts costs.
</Note>

```javascript optimized-call.js
await talkos.startCall({
  to: '+14155551234',
  
  // Set appropriate max duration
  maxDuration: 300, // 5 minutes instead of default 10
  
  // Clear, efficient prompts
  prompt: `You are a appointment reminder assistant. 
           Be concise and direct.
           Confirm the appointment, offer to reschedule, then end the call.
           Do not engage in extended conversation.`,
  
  // Enable voicemail detection to avoid wasted minutes
  voicemail: {
    enabled: true,
    action: 'leave_message',
    message: 'Hi, this is a reminder about your appointment tomorrow. Please call us back to confirm.',
    maxDuration: 30 // Short voicemail
  },
  
  // Use appropriate voice model
  voiceId: 'en-US-Standard-A' // Standard voices cost less than Neural
});
```

### Efficient Batching

```javascript efficient-batch.js
// DON'T: Start calls one by one
for (const contact of contacts) {
  await talkos.startCall({ to: contact.phone }); // Slow, inefficient
}

// DO: Use batch API
const batches = chunkArray(contacts, 500);
for (const batch of batches) {
  await talkos.batchStart({
    calls: batch.map(c => ({
      to: c.phone,
      greeting: `Hi ${c.name}!`,
      metadata: { id: c.id }
    })),
    // Shared config reduces payload size
    prompt: 'You are an appointment reminder assistant.',
    maxDuration: 180
  });
}
```

### Caching Strategies

Reduce API calls by caching where appropriate:

```javascript caching.js
import NodeCache from 'node-cache';

const cache = new NodeCache({ stdTTL: 300 }); // 5 minute cache

async function getCallStatus(callId) {
  const cacheKey = `call:${callId}`;
  
  // Check cache first
  const cached = cache.get(cacheKey);
  if (cached) return cached;
  
  // Fetch from API
  const status = await talkos.getCallStatus(callId);
  
  // Cache if call is completed (won't change)
  if (status.status === 'completed') {
    cache.set(cacheKey, status, 3600); // Cache for 1 hour
  }
  
  return status;
}
```

### Cost-Effective Voice Selection

| Voice Type | Cost | Quality | Use Case |
|------------|------|---------|----------|
| Standard | $ | Good | High-volume campaigns |
| Neural | $$ | Better | Customer-facing calls |
| Premium | $$$ | Best | High-value interactions |

```javascript voice-selection.js
function selectVoice(callType, customerTier) {
  if (callType === 'reminder' || callType === 'notification') {
    return 'en-US-Standard-A'; // Cost-effective for simple messages
  }
  
  if (customerTier === 'enterprise') {
    return 'en-US-Neural2-D'; // Premium experience for top customers
  }
  
  return 'en-US-Neural2-A'; // Good balance for general use
}
```

## Monitoring and Alerting

### Key Metrics to Track

```javascript monitoring.js
const metrics = {
  // API Performance
  apiLatency: 'talkos_api_latency_ms',
  apiErrors: 'talkos_api_errors_total',
  apiRateLimits: 'talkos_rate_limit_hits',
  
  // Call Performance
  callsInitiated: 'talkos_calls_initiated_total',
  callsCompleted: 'talkos_calls_completed_total',
  callsFailed: 'talkos_calls_failed_total',
  callDuration: 'talkos_call_duration_seconds',
  answerRate: 'talkos_answer_rate',
  
  // Cost Tracking
  dailyMinutes: 'talkos_daily_minutes_used',
  monthlySpend: 'talkos_monthly_spend_usd'
};
```

### Alert Thresholds

| Metric | Warning | Critical |
|--------|---------|----------|
| API Error Rate | > 1% | > 5% |
| Call Failure Rate | > 5% | > 15% |
| Average Latency | > 500ms | > 2000ms |
| Daily Spend | > 80% budget | > 100% budget |

### Health Check Endpoint

```javascript health-check.js
app.get('/health', async (req, res) => {
  const checks = {
    talkos: await checkTalkOSHealth(),
    database: await checkDatabaseHealth(),
    redis: await checkRedisHealth()
  };
  
  const healthy = Object.values(checks).every(c => c.status === 'healthy');
  
  res.status(healthy ? 200 : 503).json({
    status: healthy ? 'healthy' : 'degraded',
    checks,
    timestamp: new Date().toISOString()
  });
});

async function checkTalkOSHealth() {
  try {
    const start = Date.now();
    const response = await fetch('https://api.talkos.io/api/health', {
      headers: { 'x-api-key': process.env.TALKOS_API_KEY }
    });
    const latency = Date.now() - start;
    
    return {
      status: response.ok ? 'healthy' : 'unhealthy',
      latency,
      statusCode: response.status
    };
  } catch (error) {
    return { status: 'unhealthy', error: error.message };
  }
}
```

## Security Checklist

<AccordionGroup>
  <Accordion title="API Security">
    - [ ] API keys stored in environment variables
    - [ ] Keys not logged or exposed in errors
    - [ ] IP allowlisting configured (if applicable)
    - [ ] Key rotation schedule established
    - [ ] Separate keys for dev/staging/production
  </Accordion>
  
  <Accordion title="Webhook Security">
    - [ ] HTTPS endpoints only
    - [ ] Signature verification implemented
    - [ ] Replay protection (timestamp validation)
    - [ ] Idempotent processing
  </Accordion>
  
  <Accordion title="Data Protection">
    - [ ] PII handling compliant with regulations
    - [ ] Call recordings encrypted at rest
    - [ ] Transcripts access controlled
    - [ ] Data retention policies defined
  </Accordion>
  
  <Accordion title="Operational Security">
    - [ ] Audit logging enabled
    - [ ] Monitoring and alerting configured
    - [ ] Incident response plan documented
    - [ ] Regular security reviews scheduled
  </Accordion>
</AccordionGroup>
